# Правила разработки кода {#RuleCode}

При разработке системы и следующий дополнений и изменений, помимо общих концепций, соблюдаются следующие семантические, синтаксические и методологические правила написания кода

----
## Требования к проектированию

### Общий порядок проектирования кода

#### Общее
1. Добавлять в типы которые реализуют метод ToString() - шаблон для формирования строки чтобы иметь возможность влиять на результат метода
2. Реализация интерфейсов *IDisposable*, *IEnumerable*, *IEnumerator* реализовывать сразу после секции **Системные методы**
3. Реализация паттерна IDisposable делать по шаблону
4. Обеспечивать реализацию для равенства и сортировки только системных интерфейсов *IEquatable* *IComparable*, для особых или дополнительных случаев равенства и сортировки использовать вспомогательные классы с производные от *Comparer* и *EqualityComparer*
5. Для строк использовать методы: для равенства *Equals*, для сортировки *CompareOrdinal*  

#### Методы глобальных инициализацией
1. Объекты не требующее дополнительной инициализации делать по шаблону
2. Объекты требующее дополнительной инициализации оформляются по шаблону

#### Сохранение/загрузка данных из формата XML
1. Обязательное определение имя корня через константу в объявлении класса
2. Обязательно определение атрибута «версия» и при загрузки контролировать версии данных 
3. Чтение поддерева документа XML предусматривается только в том случае если объем данных неизвестен
4. Чтение элементов и атрибутов документа XML должно быть максимально безопасным
5. Образец загрузки документа делать по шаблону


### Требования к проектирования кода для Unity
1. Первоначальную инициализацию переменных в компонентах лучше делать **в области объявления данных**. В методе *Reset()* можно повторно делать инициализацию переменных значениями по умолчанию.
2. Ссылочные типы (классы) также лучше создавать в **области объявления данных** или создавать с проверкой на **null** в отдельном методе *OnInit()* - это так называемая безопасная инициализация. Данный метод следует вызывать в методах *Reset()* и *Awake()*.
3. Если компонент имеет начальную инициализацию (метод *OnInit()*) и добавляется как компонент или создается из префаба динамически(методом **Instantiate**), то он должен обязательно реализовать метод *Awake()* (будет именоваться псевдоконструктор скрипта)
4. Типовое использование метода *Awake()* - Псевдоконструктор скрипта (нужно реализовать безопасную первичную инициализацию)
5. Типовое использование метода *OnEnable()* - Включение компонента (нужно реализовать присоединение к диспетчеру подсистемы и при необходимости дополнительную инициализацию необходимую после включения компонента)
6. Типовое использование метода *Start()* - Старт скрипта (реализовать только если нужен правильный порядок инициализации)
7. Типовое использование метода *OnDisable()* - Выключение компонента (нужно реализовать отсоединение от диспетчера подсистемы)
8. При удалении объекта(компонента или игрового объекта) информировать об этом событие **на следующем кадре** используя отложенный вызов через коротуну
9. Если используется атрибут `ExecuteInEditMode` то метод **Start** вызывается в режиме редактора и **после выхода из режима игры**

### Требования к проектирования кода для Windows
Все элементы управления располагаются в директории и поддиректориях **Source/Controls**
Селектор для стилей и шаблонов данных, шаблоны данных в формате XAML располагаются в отдельной директории **View**

#### Требование к разметки XAML
**Основные пространства имен**
xmlns:core="http://schemas.cubex.core"
xmlns:ctrl="http://schemas.cubex.controls"

**Пространства имен для локальных элементов управления**
xmlns:local="clr-namespace:CubeX.Controls"

----
## Требования к семантике кода

### Общие указания
1. Обработку ошибок вести на английском языке. Неправильные параметры/ошибки обрамлять угловыми скобками.

### Требования к наименование файлов
1. Для редактора Unity - классы реализующие отдельные редакторы имеют суффикс **Editor**
2. Для редактора Unity - классы реализующие отдельные окна имеют суффикс **Window**
3. Для редактора Unity - классы реализующие рисование атрибутов имеют суффикс **Drawer**
4. Для Windows - классы реализующие селекторы для выбора шаблона модели имеют суффикс **DataSelector**

### Требования к наименование аргументов
1. Имена аргументов делать в snake_case стиле.
2. В методах компонентов исключать имена аргументов **name** - для избежание путаницы с именем компонента. И для унификации в аргументах или локальных переменных использовать суффикс имени в конце - element_name, window_name.
3. Если аргумент имеет тип делегата и предназначен только для информирования(т.е. допускается значение null) то имя обязательно начинается с префикса **on_**
4. Если аргумент имеет тип делегата и предназначен для конкретного выполнения работ (т.е. не допускается значение null) то имя обязательно оканчивается на суффикс **_delegate**

### Требования к наименование типов
1. Имена классов начинаются с префикса **C**, потом идет логическое деление, допускается не использовать префикс если есть однозначный суффикс. 
2. Имена статических классов(содержащих только статические данные) начинаются с префикса **X**, потом логическое деление.
3. Имена структур, перечислений, делегатов начинаются с префикса **T**, потом логическое деление, допускается на использовать префикс если есть однозначный суффикс. Также не будет использоваться для математической подсистемы.
4. Все делегаты должны иметь суффикс: **EventHandler**
5. Имена интерфейсов начинаются с префикса **I**, потом логическое деление. Дополнительно: все интерфейсы именуются с **ICubeX** 
6. Имена компонентов **Unity** начинаются с префикса **CubeX**.
7. Имена пользовательских ресурсов(производных от ScriptableObject) **Unity** начинаются с префикса **CubeX**. 
8. Имена атрибутов начинаются с префикса **CubeX**.
9. Классы содержащие только методы расширений начинаются с префикса **XExtension**. 

### Требование к наименованию полей и свойств
1. Свойства, поля имеющие тип аппаратно-независимых единиц имеют префикс/суффикс **Unit** 
2. Свойства, поля имеющие тип родных медиа-ресурсов WPF имеют префикс **Windows** 
3. Все свойства или поля имеющие тип делегата или события имеют префикс **On** - для информирования
4. Если событие/делегат имеет целью только информирование - то должно быть соответствующие окончание: **Added**, **Changed**, **Removed**, **Moved**
5. Все свойства или поля имеющие тип делегата или события имеют префикс и предназначенные для реальной работы имееют окончание: **Delegate**
6. Булевы свойства или поля должны иметь префикс **Is**, **In**

### Требование к наименованию методов
1. Методы предназначенные только для обработки изменения соответствующих свойств должны иметь префикс **Raise**(по умолчанию делать защищенными и виртуальными) 
2. Методы предназначенные для внешнего использования и которые работают как события должны иметь префикс **On** или **OnEvent** 
3. Методы которые производят вычисления (обычно сложные), кроме общепринятых, должны иметь префикс: **Compute** 
4. Методы предназначенные для коротун и возвращающие тип **IEnumerator** должны иметь окончание **Iteration**
5. Методы предназначенные для обработки событий должны иметь окончание **Handler**
6. Для стандартного механизма чтения XML добавлять в название методов соответствующие префиксы: **Unity**, **Math**, **CAD**, **Win**
7. Применительно к Unity. Методы предназначенные для работы в только режиме исполнения программы должны иметь окончание **InGame** (или **InRuntime**) и соответственно методы предназначенные для работы только в режиме разработке должны иметь название **InDesign** и если требуется разграничить работу только режиме редактора должны иметь окончание **InDesignEditor** и только в режиме запуска - **InDesignRuntime** 

### Требование к наименованию элементов Windows
1. Имя ключей ресурсов указывать с большой буквы с соответствующем суффиксом **Style**, **Template**, **Brush**  и т.д. и с окончанием **Key** 
2. Имена элементов указывать с маленькой буквы с префиксом типа элемента и с большой буквы если они имееют публичный доступ
3. Имена обработчиков событий указывать по форме `On[ТипЭлемента][ИмяЭлемента][Функция][Событие]`
4. Классы производные от DataTemplateSelector должный иметь суффикс **DataSelector**
5. Классы производные от StyleSelector должный иметь суффикс **StyleSelector**

### Требование к группированию членов класса

1.  **Константные данные**
2.  **Статические данные**
3.  **Статические свойства**
4.  **Статические методы**
5.  **Данные**
6.  **Свойства**
7.  **Свойства - реализация интерфейсов**
8.  **Конструкторы** (или **События Unity**)
9.  **Системные методы** (реализация системных интерфейсов)
10. **Реализация системных интерфейсов ** (реализация интерфейсов которые имеют несколько методов)
11. **Операторы**
12. **Операторы преобразования**
13. **Индексатор**
14. **Служебные методы событий** (методы имеющие префикс **Raise**)
15. **Реализация интерфейсов** (реализация пользовательских интерфейсов)
16. **Общие методы**
17. **Другие методы по группам**
18. **Методы сериализации**